name: release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release (vX.Y.Z)"
        required: true
        type: string
  push:
    tags:
      - "v*"

concurrency:
  group: release-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.tag || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  RELEASE_TAG: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.tag || github.ref_name }}

jobs:
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            apps/web/package-lock.json
            apps/desktop/package-lock.json

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.21"
          cache: true
          cache-dependency-path: services/api/go.sum

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            apps/desktop/src-tauri -> target

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Install frontend deps
        working-directory: apps/web
        run: npm ci

      - name: Install desktop deps
        working-directory: apps/desktop
        run: npm ci

      - name: Build backend (mac/linux)
        if: runner.os != 'Windows'
        run: scripts/build-backend.sh

      - name: Build backend (windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: scripts/build-backend.ps1

      - name: Verify backend binary (mac/linux)
        if: runner.os != 'Windows'
        run: |
          test -f apps/desktop/src-tauri/bin/ionicx-api

      - name: Verify backend binary (windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (-not (Test-Path "apps/desktop/src-tauri/bin/ionicx-api.exe")) {
            Write-Error "Backend binary not found at apps/desktop/src-tauri/bin/ionicx-api.exe"
            exit 1
          }

      - name: Build frontend
        working-directory: apps/web
        run: npm run build

      - name: Build desktop
        working-directory: apps/desktop
        run: npm run tauri build

      # Optional macOS signing + notarization (requires secrets)
      # - name: Import signing cert
      #   if: runner.os == 'macOS'
      #   uses: apple-actions/import-codesign-certs@v3
      #   with:
      #     p12-file-base64: ${{ secrets.MACOS_CERT_P12 }}
      #     p12-password: ${{ secrets.MACOS_CERT_PASSWORD }}
      # - name: Notarize
      #   if: runner.os == 'macOS'
      #   run: |
      #     xcrun notarytool submit <path-to-dmg> \
      #       --apple-id "${{ secrets.MACOS_APPLE_ID }}" \
      #       --team-id "${{ secrets.MACOS_TEAM_ID }}" \
      #       --password "${{ secrets.MACOS_APP_SPECIFIC_PASSWORD }}" \
      #       --wait

      # Optional Windows code signing (requires secrets)
      # - name: Sign Windows artifacts
      #   if: runner.os == 'Windows'
      #   shell: pwsh
      #   run: |
      #     signtool.exe sign /fd sha256 /a /f $env:WINDOWS_CERT_PFX /p $env:WINDOWS_CERT_PASSWORD <path-to-msi-or-exe>

      - name: Stage release assets (macOS/Linux)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob

          OUT_DIR="release-assets"
          BUNDLE_DIR="apps/desktop/src-tauri/target/release/bundle"
          mkdir -p "$OUT_DIR"

          if [[ "${RUNNER_OS}" == "macOS" ]]; then
            arch="$(uname -m)"
            case "$arch" in
              arm64) mac_arch="arm64" ;;
              x86_64) mac_arch="x64" ;;
              *) mac_arch="$arch" ;;
            esac

            universal_dmg=("$BUNDLE_DIR"/dmg/*universal*.dmg)
            if [[ -f "${universal_dmg[0]:-}" ]]; then
              cp "${universal_dmg[0]}" "$OUT_DIR/ionicx-macos-universal.dmg"
            else
              for f in "$BUNDLE_DIR"/dmg/*.dmg; do
                cp "$f" "$OUT_DIR/ionicx-macos-${mac_arch}.dmg"
              done
            fi

            for f in "$BUNDLE_DIR"/macos/*.app.zip; do
              cp "$f" "$OUT_DIR/ionicx-macos-${mac_arch}.app.zip"
            done

            app_dir=("$BUNDLE_DIR"/macos/*.app)
            if [[ -d "${app_dir[0]:-}" ]]; then
              /usr/bin/ditto -c -k --sequesterRsrc --keepParent \
                "${app_dir[0]}" "$OUT_DIR/ionicx-macos-${mac_arch}.app.zip"
            fi
          fi

          if [[ "${RUNNER_OS}" == "Linux" ]]; then
            arch="$(uname -m)"
            case "$arch" in
              x86_64)
                appimage_arch="x86_64"
                deb_arch="amd64"
                rpm_arch="x86_64"
                ;;
              aarch64|arm64)
                appimage_arch="aarch64"
                deb_arch="arm64"
                rpm_arch="aarch64"
                ;;
              *)
                appimage_arch="$arch"
                deb_arch="$arch"
                rpm_arch="$arch"
                ;;
            esac

            for f in "$BUNDLE_DIR"/appimage/*.AppImage; do
              cp "$f" "$OUT_DIR/ionicx-linux-${appimage_arch}.AppImage"
            done
            for f in "$BUNDLE_DIR"/deb/*.deb; do
              cp "$f" "$OUT_DIR/ionicx-linux-${deb_arch}.deb"
            done
            for f in "$BUNDLE_DIR"/rpm/*.rpm; do
              cp "$f" "$OUT_DIR/ionicx-linux-${rpm_arch}.rpm"
            done
          fi

          count=$(ls -1 "$OUT_DIR" | wc -l | tr -d ' ')
          if [[ "$count" -eq 0 ]]; then
            echo "No release assets found."
            exit 1
          fi

      - name: Stage release assets (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $outDir = "release-assets"
          $bundleDir = "apps/desktop/src-tauri/target/release/bundle"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $arch = $env:PROCESSOR_ARCHITECTURE
          if ($arch -eq "ARM64") { $winArch = "arm64" } else { $winArch = "x64" }

          $msi = Get-ChildItem -Path (Join-Path $bundleDir "msi") -Filter *.msi -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($msi) {
            Copy-Item $msi.FullName (Join-Path $outDir ("ionicx-windows-$winArch.msi")) -Force
          }

          $exe = Get-ChildItem -Path (Join-Path $bundleDir "nsis") -Filter *.exe -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($exe) {
            Copy-Item $exe.FullName (Join-Path $outDir ("ionicx-windows-$winArch.exe")) -Force
          }

          $count = (Get-ChildItem -Path $outDir -File -ErrorAction SilentlyContinue | Measure-Object).Count
          if ($count -eq 0) {
            Write-Error "No release assets found."
            exit 1
          }

      - name: Upload installers
        uses: actions/upload-artifact@v4
        with:
          name: ionicx-${{ matrix.os }}
          path: release-assets/*

  release:
    name: Release
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: write

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-assets
          merge-multiple: true

      - name: List assets
        run: ls -la release-assets

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          generate_release_notes: true
          files: |
            release-assets/*
